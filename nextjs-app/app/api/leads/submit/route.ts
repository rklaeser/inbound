// POST /api/leads/submit
// Accept new lead from form submission

import { NextRequest, NextResponse } from "next/server";
import { adminDb } from "@/lib/db";
import type { Lead, Classification, BotResearch } from "@/lib/types";
import { z } from "zod";
import { start } from "workflow/api";
import { workflowInbound } from "@/workflows/inbound";
import { getConfiguration } from "@/lib/configuration-helpers";
import { getCachedCaseStudies } from "@/lib/case-studies";
import { detectDuplicate } from "@/lib/db/mock-crm";

// Validation schema
const leadFormSchema = z.object({
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Valid email is required"),
  company: z.string().min(1, "Company is required"),
  message: z.string().min(10, "Message must be at least 10 characters"),
  metadata: z.object({
    isTestLead: z.boolean(),
    testCase: z.string(),
    expectedClassification: z.string(),
  }).optional(),
});

export async function POST(request: NextRequest) {
  try {
    // Parse request body
    const body = await request.json();

    // Validate input
    const validationResult = leadFormSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        {
          success: false,
          error: validationResult.error.errors[0].message,
        },
        { status: 400 }
      );
    }

    const leadData = validationResult.data;
    const now = new Date();

    // Step 1: Check for duplicates BEFORE any AI processing
    // This is deterministic and should always run regardless of AI classification rate
    const duplicateResult = detectDuplicate(leadData.email, leadData.company);

    if (duplicateResult.isDuplicate && duplicateResult.matchedContact) {
      console.log(`[API] Duplicate detected: ${duplicateResult.matchReason}`);

      // Create bot_research for the duplicate
      const bot_research: BotResearch = {
        timestamp: now,
        confidence: 0.99,
        classification: 'duplicate',
        reasoning: `CRM match: ${duplicateResult.matchReason}. Customer: ${duplicateResult.matchedContact.company} (${duplicateResult.matchedContact.accountType})`,
        existingCustomer: true,
        crmRecordId: duplicateResult.matchedContact.id,
      };

      // Create lead document marked as done (auto-forwarded)
      const duplicateLead: Omit<Lead, 'id'> = {
        submission: {
          leadName: leadData.name,
          email: leadData.email,
          company: leadData.company,
          message: leadData.message,
        },
        bot_research,
        bot_rollout: {
          rollOut: 0,
          useBot: true,
        },
        email: null,  // No email for duplicates
        status: {
          status: 'done',
          received_at: now,
          sent_at: now,
          sent_by: 'system',  // Deterministic rule, not AI
        },
        classifications: [{
          author: 'bot',
          classification: 'duplicate',
          timestamp: now,
          needs_review: false,
          applied_threshold: 0,
        }],
        matched_case_studies: [],
        ...(leadData.metadata && {
          metadata: {
            isTestLead: leadData.metadata.isTestLead,
            testCase: leadData.metadata.testCase,
            expectedClassification: leadData.metadata.expectedClassification as Classification,
          }
        }),
      };

      const leadRef = await adminDb.collection("leads").add(duplicateLead);

      console.log(`[API] Duplicate lead ${leadRef.id} auto-forwarded to account team`);

      return NextResponse.json({
        success: true,
        leadId: leadRef.id,
        isDuplicate: true,
        matchedCustomer: duplicateResult.matchedContact.company,
      });
    }

    // Step 2: Check AI classification rate to determine routing for non-duplicates
    // Even when human classifies, we still run AI silently for comparison
    const config = await getConfiguration();
    const aiClassificationRate = config.rollout?.percentage || 0;
    const useAIClassification = Math.random() < aiClassificationRate;

    console.log(`[API] AI Classification Rate: ${aiClassificationRate * 100}%, useAI: ${useAIClassification}`);

    // Create initial lead document with new data model
    const initialLead: Omit<Lead, 'id'> = {
      // Submission data
      submission: {
        leadName: leadData.name,
        email: leadData.email,
        company: leadData.company,
        message: leadData.message,
      },

      // Bot outputs (null until workflow completes)
      bot_research: null,
      bot_rollout: null,

      // Email content (null until generated by workflow)
      email: null,

      // Status - start as 'processing', workflow will update to final status
      status: {
        status: 'processing',
        received_at: now,
        sent_at: null,
        sent_by: null,
      },

      // Classification history (empty until workflow completes)
      classifications: [],

      // Test metadata (optional)
      ...(leadData.metadata && {
        metadata: {
          isTestLead: leadData.metadata.isTestLead,
          testCase: leadData.metadata.testCase,
          expectedClassification: leadData.metadata.expectedClassification as Classification,
        }
      }),
    };

    // Create lead document in Firestore
    const leadRef = await adminDb.collection("leads").add(initialLead);
    const leadId = leadRef.id;

    // Pre-fetch case studies for the workflow (workflow runtime lacks setTimeout for Firebase)
    // Strip Firestore Timestamp fields that can't be serialized by workflow runtime
    const rawCaseStudies = await getCachedCaseStudies();
    const caseStudies = rawCaseStudies.map(cs => ({
      id: cs.id,
      company: cs.company,
      industry: cs.industry,
      products: cs.products,
      url: cs.url,
      logoSvg: cs.logoSvg,
      featuredText: cs.featuredText,
    }));

    // Build email template config for workflow to assemble emails
    const emailTemplateConfig = {
      greeting: config.emailTemplates.highQuality.greeting,
      callToAction: config.emailTemplates.highQuality.callToAction,
      signOff: config.emailTemplates.highQuality.signOff,
      senderName: config.sdr.name,
      senderLastName: config.sdr.lastName,
      senderEmail: config.sdr.email,
      senderTitle: config.sdr.title,
    };

    // Always trigger workflow - AI classification runs for comparison even when human will classify
    // The workflow will persist results directly to Firestore when done
    // - useAIClassification=true: Bot classification is authoritative, lead goes to review/done
    // - useAIClassification=false: Bot classification is stored for comparison only, human must classify
    start(workflowInbound, [{
      lead: leadData,
      caseStudies,
      config: {
        thresholds: config.thresholds,
        rollout: config.rollout,
        allowHighQualityAutoSend: config.allowHighQualityAutoSend,
        experimentalCaseStudies: config.experimental?.caseStudies ?? false,
      },
      // Context for the workflow to persist results
      leadId,
      useAIClassification,
      emailTemplateConfig,
    }]).then((run) => {
      console.log(`[API] Workflow started with run ID: ${run.runId}`);
    }).catch((error) => {
      console.error(`[API] Failed to start workflow for lead ${leadId}:`, error);
    });

    return NextResponse.json({
      success: true,
      leadId,
      aiClassified: useAIClassification,
      aiComparisonPending: !useAIClassification, // AI runs for comparison even when human classifies
    });
  } catch (error) {
    console.error("Failed to save lead to Firestore:", error);
    return NextResponse.json(
      {
        success: false,
        error: "Unable to submit your inquiry. Please try again in a moment.",
      },
      { status: 500 }
    );
  }
}
